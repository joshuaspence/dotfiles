#!/bin/sh

source $HOME/.shell/functions/color

##
# Prints out contextual git state for the command prompt.
#
# @link http://github.com/darkhelmet/dotfiles
# @link http://github.com/fnichol/bashrc/blob/master/bashrc
#
git_state() {
    if ! git rev-parse >/dev/null 2>&1; then
        return 1
    fi

    local git_status=$(git -c color.status=false status --short --branch 2>/dev/null)

    local bits=
    printf $git_status | egrep -q '^ ?M'      && bits="${bits}\xb1" # modified files
    printf $git_status | egrep -q '^ ?\?'     && bits="${bits}?"    # untracked files
    printf $git_status | egrep -q '^ ?A'      && bits="${bits}\*"   # new/added files
    printf $git_status | egrep -q '^ ?R'      && bits="${bits}>"    # renamed files
    printf $git_status | egrep -q '^ ?D'      && bits="${bits}\xa7" # deleted files
    printf $git_status | egrep -q ' \[ahead ' && bits="${bits}+"    # ahead of origin

    local branch=$(echo $git_status | egrep '^## ' | awk '{print $2}' | sed 's/\.\.\..*$//')
    [ $branch == "Initial commit on master" ] && branch="nobranch"

    local last_commit=$(git log --pretty=format:'%at' -1 2>/dev/null)
    local age="-1"
    if [ -n $last_commit ]; then
        age=$(( $(( $(date +%s)-last_commit )) / 60 )) # zomg nesting
    fi

    # Color
    local age_color=
    if [ $age -lt 0 ]; then
        age_color="cyan"
    elif [ $age -gt 60 ]; then
        age_color="red"
    elif [ $age -gt 30 ]; then
        age_color="yellow"
    else
        age_color="green"
    fi

    # If age is more than 7 days, show in days otherwise minutes.
    if [ $age -gt 10080 ]; then
        age=$(printf "%dd" $(( age / 1440 )))
    else
        age=$(printf "%dm" $age)
    fi

    case $TERM in
        *term | xterm-* | rxvt | screen | screen-* )
            age="$(bput $age_color)$age$(bput rst)"
            bits="$(bput cyan)$bits$(bput rst)"
            ;;
    esac

    if [ $SHELL_COLOR -eq 1 ]; then
        printf "%b" " $(bput magenta)${cvstool}(${age}$(bput magenta)|$(bput rst)${branch}${bits}$(bput magenta))$(bput rst)"
    else
        printf "%b" " $(bput magenta)${cvstool}(${age}$(bput magenta)|$(bput rst)${branch}${bits}$(bput magenta))$(bput rst)"
    fi
    return 0
}

##
# Prints out contextual hg state for the command prompt.
#
# @link http://github.com/darkhelmet/dotfiles
# @link http://github.com/fnichol/bashrc/blob/master/bashrc
#
hg_state() {
    if ! hg --repository $(pwd) root >/dev/null 2>&1; then
        return 1
    fi

    local hg_status=$(hg status --config 'extensions.color=!' 2>/dev/null)

    local bits=
    printf $hg_status | egrep -q '^M '  && bits="${bits}\xb1" # modified files
    printf $hg_status | egrep -q '^\? ' && bits="${bits}?"    # untracked files
    printf $hg_status | egrep -q '^A '  && bits="${bits}\*"   # new files
    printf $hg_status | egrep -q '^! '  && bits="${bits}\!"   # deleted files
    printf $hg_status | egrep -q '^R '  && bits="${bits}\xa7" # removed files

    local branch=$(hg branch)
    [ -z $branch ] && branch="nobranch"

    local last_commit=$(hg log -l 1 --template '{date|hgdate}' 2>/dev/null | awk '{print $1}')

    printf $(_prompt_state "hg" "$branch" "$last_commit" "$bits")
    return 0
}

svn_state() {
    prompt_getcolors
    local info="$(svn info . 2> /dev/null)"
    local last current
    if [[ "$info" ]]; then
        last="$(echo "$info" | awk '/Last Changed Rev:/ {print $4}')"
        current="$(echo "$info" | awk '/Revision:/ {print $2}')"
        echo "$c1[$c0$last$c1:$c0$current$c1]$c9"
    fi
}

##
# TODO
#
prompt_state() {
    prompt_state_git
    prompt_state_hg
}

##
# Sets a shell prompt. Uses a set variable of "PROMPT_COLOR" to determine the
# main color of the prompt, if it exists. If a variable of "REMOTE_PROMPT_COLOR"
# is given, then this color will be used for all remote SSH sessions.
#
bash_prompt() {
    [ -z $PROMPT_COLOR ] && PROMPT_COLOR="default"

    # Change prompt color if remotely logged in and alt color is given
    if [[ -n $SSH_CLIENT && -n $REMOTE_PROMPT_COLOR ]]; then
        PROMPT_COLOR=$REMOTE_PROMPT_COLOR
    fi

    if [ "$(id --user --real)" -eq "0" ]; then # CAN THIS BE DONE BETTER
        # Root shell
        local user_c="#"
        local tb=$user_c
        local color="red"
    else
        local user_c=">"
        local tb=
        local color=$PROMPT_COLOR
    fi

    case $TERM in
        *term | xterm-* | rxvt | screen | screen-*)
            local cyan="\[$(bput cyan)\]"
            if [ -z "$bashrc_light_bg" ]; then
                local white="\[$(bput white)\]"
            else
                local white="\[$(bput black)\]"
            fi
            local nocolor="\[$(bput rst)\]"
            local custom="\[$(bput $color)\]"
            local titlebar="\[\033]0;${tb}\u@\h:\w${tb}\007\]"
            ;;
        *)
            local cyan=
            local white=
            local nocolor=
            local custom=
            local titlebar=
            ;;
    esac

    local prompt_core=
    if [[ -n $SSH_TTY || "$(id --user --real)" -eq "0" ]]; then
        local prompt_core="\u@\h"
    fi

    PS1="${titlebar}${cyan}[${custom}\$(short_pwd)${white}\ $(prompt_state)${cyan}]${nocolor}\n${custom}${prompt_core}${user_c} ${nocolor}"
    PS2="${custom}${user_c} ${nocolor}"
}


export PS1="\[\033[0;37m\]\342\224\214\342\224\200\$([[ \$? != 0 ]] && echo \"[\[\033[0;31m\]\342\234\227\[\033[0;37m\]]\342\224\200\")[$(if [[ ${EUID} == 0 ]]; then echo '\[\033[0;31m\]\h'; else echo '\[\033[0;33m\]\u\[\033[0;37m\]@\[\033[0;96m\]\h'; fi)\[\033[0;37m\]]\342\224\200[\[\033[0;32m\]\w\[\033[0;37m\]]\n\[\033[0;37m\]\342\224\224\342\224\200\342\224\200\342\225\274 \[\033[0m\]"

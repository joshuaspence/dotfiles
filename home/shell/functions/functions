#!/bin/bash

RETURN_SUCCESS=0
RETURN_NOT_DEFINED=1
RETURN_INVALID_CALL=2
RETURN_MISSING_EXEC=3
RETURN_INVALID_PARAMS=4

#===============================================================================
# System
#===============================================================================

##
# Returns the operating system kernel name.
#
function os() {
    uname -s
    return $RETURN_SUCCESS
}

##
# Performs an egrep on the process list. Use any arguments that egrep accepts.
#
# @param [Array] egrep arguments.
#
# @link http://github.com/fnichol/bashrc/blob/master/bashrc
#
function psg() {
    case "$(os)" in
        Darwin|OpenBSD) ps wwwaux | egrep "($@|\bPID\b)" | egrep -v "grep" ;;
        SunOS|Linux)    ps -ef    | egrep "($@|\bPID\b)" | egrep -v "grep" ;;
        CYGWIN_*)       ps -efW   | egrep "($@|\bPID\b)" | egrep -v "grep" ;;
        *)              return $RETURN_NOT_DEFINED ;;
    esac
    return $RETURN_SUCCESS
}

#===============================================================================
# Prompt
#===============================================================================

##
# TODO
#
# @param [String] TODO
# @param [String] TODO
# @param [Integer] TODO
# @param [String] TODO
#
function __prompt_state() {
    local cvstool=$1
    local branch=$2
    local last_commit=$3
    local bits=$4

    # Age
    local age="-1"
    if [ -n "$last_commit" ] ; then
        age=$(( $(( $(date +%s)-last_commit )) / 60 )) # zomg nesting
    fi

    # Color
    local age_color=
    if [ "$age" -lt 0 ] ; then
        age_color="cyan"
    elif [ "$age" -gt 60 ] ; then
        age_color="red"
    elif [ "$age" -gt 30 ] ; then
        age_color="yellow"
    else
        age_color="green"
    fi

    # If age is more than 7 days, show in days otherwise minutes
    if [ "$age" -gt 10080 ] ; then
        age=$(printf "%dd" $(( age / 1440 )))
    else
        age=$(printf "%dm" $age)
    fi

    case "$TERM" in
        *term | xterm-* | rxvt | screen | screen-* )
            age="$(bput $age_color)$age$(bput rst)"
            bits="$(bput cyan)$bits$(bput rst)"
            ;;
    esac

    printf "%b" " $(bput magenta)${cvstool}(${age}$(bput magenta)|$(bput rst)${branch}${bits}$(bput magenta))$(bput rst)"
    return $RETURN_SUCCESS
}

##
# Prints out contextual git state for the command prompt.
#
# @link http://github.com/darkhelmet/dotfiles
# @link http://github.com/fnichol/bashrc/blob/master/bashrc
#
function prompt_state_git() {
    if git rev-parse ; then
        local git_status=$(git -c color.status=false status --short --branch 2>/dev/null)

        local bits=
        printf $git_status | egrep -q '^ ?M'      && bits="${bits}\xb1" # modified files
        printf $git_status | egrep -q '^ ?\?'     && bits="${bits}?"    # untracked files
        printf $git_status | egrep -q '^ ?A'      && bits="${bits}\*"   # new/added files
        printf $git_status | egrep -q '^ ?R'      && bits="${bits}>"    # renamed files
        printf $git_status | egrep -q '^ ?D'      && bits="${bits}\xa7" # deleted files
        printf $git_status | egrep -q ' \[ahead ' && bits="${bits}+"    # ahead of origin

        local branch=$(echo $git_status | egrep '^## ' | awk '{print $2}' | sed 's/\.\.\..*$//')
        [ "${branch}" == "Initial commit on master" ] && branch="nobranch"

        local last_commit=$(git log --pretty=format:'%at' -1 2>/dev/null)

        printf $(__prompt_state "git" "$branch" "$last_commit" "$bits")
        return $RETURN_SUCCESS
    else
        return $RETURN_INVALID_CALL
    fi
}

##
# Prints out contextual hg state for the command prompt.
#
# @link http://github.com/darkhelmet/dotfiles
# @link http://github.com/fnichol/bashrc/blob/master/bashrc
#
function prompt_state_hg() {
    if hg --repository $(pwd) root 2>/dev/null ; then
        local hg_status=$(hg status --config 'extensions.color=!' 2>/dev/null)

        local bits=
        printf $hg_status | egrep -q '^M '   && bits="${bits}\xb1" # modified files
        printf $hg_status | egrep -q '^\? '  && bits="${bits}?"    # untracked files
        printf $hg_status | egrep -q '^A '   && bits="${bits}\*"   # new files
        printf $hg_status | egrep -q '^! '   && bits="${bits}\!"   # deleted files
        printf $hg_status | egrep -q '^R '   && bits="${bits}\xa7" # removed files

        local branch=$(hg branch)
        [ -z "$branch" ] && branch="nobranch"

        local last_commit=$(hg log -l 1 --template '{date|hgdate}' 2>/dev/null | awk '{print $1}')

        printf $(__prompt_state "hg" "$branch" "$last_commit" "$bits")
        return $RETURN_SUCCESS
    else
        return $RETURN_INVALID_CALL
    fi
}

##
# TODO
#
function prompt_state() {
    prompt_state_git
    prompt_state_hg

    if command -v chruby >/dev/null && [[ -n "$RUBY_ROOT" ]] ; then
        printf "%b" " {$(basename $RUBY_ROOT)}"
    elif command -v rvm-prompt >/dev/null ; then
        printf "%b" " {$(rvm-prompt)}"
    fi
}

##
# Sets a shell prompt. Uses a set variable of `PROMPT_COLOR' to determine the
# main color of the prompt, if it exists. This is generally set in bashrc.local.
# If a variable of `REMOTE_PROMPT_COLOR' is given, then this color will be used
# for all remote SSH sessions.
function bash_prompt() {
    [ -z "$PROMPT_COLOR" ] && PROMPT_COLOR="default"

    # Change prompt color if remotely logged in and alt color is given
    if [[ -n "$SSH_CLIENT" && -n "$REMOTE_PROMPT_COLOR" ]] ; then
        PROMPT_COLOR="$REMOTE_PROMPT_COLOR"
    fi

    if [ "$(id --user --real)" -eq "0" ] ; then
        # Root shell
        local user_c="#"
        local tb=$user_c
        local color="red"
    else
        local user_c=">"
        local tb=
        local color=$PROMPT_COLOR
    fi

    case "$TERM" in
        *term|xterm-*|rxvt|screen|screen-*)
            local cyan="\[$(bput cyan)\]"
            if [ -z "$bashrc_light_bg" ] ; then
                local white="\[$(bput white)\]"
            else
                local white="\[$(bput black)\]"
            fi
            local nocolor="\[$(bput rst)\]"
            local custom="\[$(bput $color)\]"
            local titlebar="\[\033]0;${tb}\u@\h:\w${tb}\007\]"
            ;;
        *)
            local cyan=
            local white=
            local nocolor=
            local custom=
            local titlebar=
            ;;
    esac

    local prompt_core=
    if [[ -n "$SSH_TTY" || "$(id --user --real)" -eq "0" ]] ; then
        local prompt_core="\u@\h"
    fi

    PS1="${titlebar}${cyan}[${custom}\$(short_pwd)${white}\ $(prompt_state)${cyan}]${nocolor}\n${custom}${prompt_core}${user_c} ${nocolor}"
    PS2="${custom}${user_c} ${nocolor}"
}

#===============================================================================
# Navigation
#===============================================================================

##
# Creates the directory if it doesn't exist, and changes into it.
#
# @param [String] The path of the new directory.
function mcd() {
    local dir="$1"

    if command -v pushd >/dev/null; then
        local cd_cmd=$(command -v pushd)
    else
        local cd_cmd=$(which cd)
    fi

    mkdir -p ${dir} && ${cd_cmd} ${dir} >/dev/null
}

##
# Calculates are truncated pwd. Overriding of the truncation length can be done
# by setting `PROMPT_LEN'.
#
# Thanks to: https://gist.github.com/548242 (@nicksieger)
function short_pwd () {
    local pwd_length=${PROMPT_LEN-35}
    local cur_pwd=$(echo $(pwd) | sed -e "s,^$HOME,~,")

    if [ $(echo -n $cur_pwd | wc -c | tr -d " ") -gt $pwd_length ]; then
        echo "...$(echo $cur_pwd | sed -e "s/.*\(.\{$pwd_length\}\)/\1/")"
    else
        echo $cur_pwd
    fi
}

#===============================================================================
# String
#===============================================================================

##
# Create box of '#' characters around given string.
#
# @param [String] The string that is to be enclosed within a box.
# @param [String] The character to enclose the string within.
function box() {
    local t="$1xxxx"
    local c=${2:-#}
    c=${c:0:1} # take only the first character of c
    echo ${t//?/$c}
    echo "$c $1 $c"
    echo ${t//?/$c}
}

#===============================================================================
# Network
#===============================================================================

##
# Returns the primary IP address of the system.
function whatsmy_primary_ip() {
    local def_gateway=
    local iface=
    local ip=

    case $(os) in
        Darwin)
            iface=$(netstat -nr | grep ^default | grep -v 'link#' | awk '{print $6}')
            ip=$(ifconfig $_if | grep '^[[:space:]]*inet ' | awk '{print $2}')
            ;;
        OpenBSD)
            iface=$(netstat -nr | grep ^default | awk '{print $8}')
            ip=$(ifconfig $_if | grep '^[[:space:]]*inet ' | awk '{print $2}')
            ;;
        Linux)
            iface=$(netstat -nr | grep ^0\.0\.0\.0 | awk '{print $8}')
            ip=$(/sbin/ifconfig $_if | grep '^[[:space:]]*inet ' | awk '{print $2}' | awk -F':' '{print $2}')
            ;;
        SunOS)
            def_gateway=$(netstat -nr | grep ^default | awk '{print $2}')
            iface=$(route get $_def_gateway | \ grep '^[ ]*interface:' | awk '{print $2}')
            ip=$(ifconfig $_if |  awk '/^\t*inet / {print $2}')
            ;;
    esac

    if [[ -z $ip || $ip == "" ]]; then
        echo "Could not determine primary IP address" >&2
        return 10
    else
        echo $ip
    fi
}

##
# Determines the primary hostname of another domain name. Often used to resolve
# a website url (like `www.example.com') to a server hostname (like
# `webserver1.domainhosting.com').
#
# @params [String] Domainname to look up.
function hostfromdomain() {
    if command -v dig >/dev/null; then
        [[ -z "$1" ]] && printf "usage: hostfromdomain <domainname>\n" && return 11
        dig -x $(dig $1 +short) +short
    else
        echo "dig command not available" >&2
        return 5
    fi
}

##
# Returns the public/internet visible IP address of the system.
#
# @link https://twitter.com/#!/mojombo/status/48948402955882496
function whatsmy_public_ip() {
    curl --silent 'http://jsonip.com/' | json_val '["ip"]'
}

##
# Return current external IP address.
function whatismyip() {
    curl --silent checkip.dyndns.org | sed -e 's/.*Current IP Address: //' -e 's/<.*$//'
}

##
# Returns the remote user's public SSH key on STDOUT. The host can optionally
# contain the username (like `jdoe@ssh.example.com') and a non-standard port
# number (like `ssh.example.com:666').
#
# @param [String] remote ssh host in for form of [<user>@]host[:<port>]
# @param [String] remote public key, using id_dsa.pub by default
function mysshkey() {
    if [ -z "$1" ] ; then
        echo "Usage: mysshkey <ssh_host> [<pub_key>]" >&2
        return $RETURN_INVALID_CALL
    fi

    local host="$1" ; shift
    if [ -z "$1" ] ; then
        local key="id_dsa.pub"
    else
        local key="$1"
    fi
    shift

    if echo "$host" | egrep -q ':' ; then
        local ssh_cmd=$(echo $host | awk -F':' '{print \"ssh -p \" $2 \" \" $1}')
    else
        local ssh_cmd="ssh $host"
    fi

    $ssh_cmd "(cat .ssh/$key)"
}

##
# Places a given public ssh key on a remote host for key-based authentication.
# The host can optionally contain the username (like `jdoe@ssh.example.com')
# and a non-standard port number (like `ssh.example.com:666').
#
# @param [String] remote ssh host in for form of [<user>@]host[:<port>]
# @param [String] public key, using $HOME/.ssh/id_dsa.pub by default
function authme() {
    if [ -z "$1" ] ; then
        echo "Usage: authme <ssh_host> [<pub_key>]" >&2
        return $RETURN_INVALID_CALL
    fi

    local host="$1" ; shift
    if [ -z "$1" ] ; then
        local key="${HOME}/.ssh/id_dsa.pub"
    else
        local key="$1"
    fi
    shift

    [[ ! -f "$key" ]] && echo "SSH key: $key does not exist." && return 11

    if echo "$host" | egrep -q ':' ; then
        local ssh_cmd="$(echo $host | awk -F':' '{print \"ssh -p \" $2 \" \" $1}')"
    else
        local ssh_cmd="ssh $host"
    fi

    $ssh_cmd '(if [ ! -d "${HOME}/.ssh" ]; then \
        mkdir -m 0700 -p ${HOME}/.ssh; fi; \
        cat - >> .ssh/authorized_keys)' < $key
}


#===============================================================================
# Utility
#===============================================================================

##
# Takes JSON on STDIN and prints the value of a given path on STDOUT.
#
# @param [String] JSON TODO
#
function json_value() {
    if [ -z "$1" ]; then
        echo "Usage: json_value <path>" >&2
        return $RETURN_INVALID_CALL
    fi

    if [ -z $(which python) ]; then
        echo "Python is required for this function" >&2
        return $RETURN_MISSING_EXEC
    fi

    local keys=
    for key in $@ ; do
        keys="${keys}['${key}']"
    done; unset key

    python -c 'import sys; import json; j = json.loads(sys.stdin.read()); print j'${keys}';'
}

##
# Calculates diskusage (with du) and reports back sorted and human readable.
#
# @param [Array] list of files or directories to report on (file args to du).
#
# @link http://github.com/lucapette/dotfiles/blob/master/bash/aliases
#
function diskusage() {
    du -ks "$@" | \
        sort -nr | \
        awk '{ \
            if ($1 > 1048576) printf("%8.2fG", $1/1048576) ; \
            else if ($1 > 1024) printf("%8.2fM", $1/1024) ; \
            else printf("%8.2fK", $1) ; \
            sub($1, "") ; print \
        }'
}

# credit: http://nparikh.org/notes/zshrc.txt
# Usage: extract <file>
# Description: extracts archived files / mounts disk images
# Note: .dmg/hdiutil is Mac OS X-specific.
function extract () {
    if [ -f $1 ]; then
        case $1 in
            *.tar.bz2)  tar -jxvf $1                        ;;
            *.tar.gz)   tar -zxvf $1                        ;;
            *.bz2)      bunzip2 $1                          ;;
            *.dmg)      hdiutil mount $1                    ;;
            *.gz)       gunzip $1                           ;;
            *.tar)      tar -xvf $1                         ;;
            *.tbz2)     tar -jxvf $1                        ;;
            *.tgz)      tar -zxvf $1                        ;;
            *.zip)      unzip $1                            ;;
            *.ZIP)      unzip $1                            ;;
            *.pax)      cat $1 | pax -r                     ;;
            *.pax.Z)    uncompress $1 --stdout | pax -r     ;;
            *.Z)        uncompress $1                       ;;
            *)          echo "'$1' cannot be extracted/mounted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

function compute() {
  while true; do head -n 100 /dev/urandom; sleep 0.1; done \
    | hexdump -C | grep "ca fe"
}

# Show how much RAM application uses.
# $ ram safari
# # => safari uses 154.69 MBs of RAM.
function ram() {
  local sum
  local items
  local app="$1"
  if [ -z "$app" ]; then
    echo "First argument - pattern to grep from processes"
  else
    sum=0
    for i in `ps aux | grep -i "$app" | grep -v "grep" | awk '{print $6}'`; do
      sum=$(($i + $sum))
    done
    sum=$(echo "scale=2; $sum / 1024.0" | bc)
    if [[ $sum != "0" ]]; then
      echo "${fg[blue]}${app}${reset_color} uses ${fg[green]}${sum}${reset_color} MBs of RAM."
    else
      echo "There are no processes with pattern '${fg[blue]}${app}${reset_color}' are running."
    fi
  fi
}

# Count code lines in some directory.
# $ loc py js css
# # => Lines of code for .py: 3781
# # => Lines of code for .js: 3354
# # => Lines of code for .css: 2970
# # => Total lines of code: 10105
function loc() {
  local total
  local firstletter
  local ext
  local lines
  total=0
  for ext in $@; do
    firstletter=$(echo $ext | cut -c1-1)
    if [[ firstletter != "." ]]; then
      ext=".$ext"
    fi
    lines=`find-exec "*$ext" cat | wc -l`
    lines=${lines// /}
    total=$(($total + $lines))
    echo "Lines of code for ${fg[blue]}$ext${reset_color}: ${fg[green]}$lines${reset_color}"
  done
  echo "${fg[blue]}Total${reset_color} lines of code: ${fg[green]}$total${reset_color}"
}

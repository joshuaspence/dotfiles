#!/bin/sh

##
# Create box of '#' characters around given string.
#
# @param [String] The string that is to be enclosed within a box.
# @param [String] The character to enclose the string within.
#
box() {
    local t="$1xxxx"
    local c=${2:-#}
    c=${c:0:1} # take only the first character of c
    echo ${t//?/$c}
    echo "$c $1 $c"
    echo ${t//?/$c}
    return 0
}

##
# Takes JSON on STDIN and prints the value of a given path on STDOUT.
#
# @param [String] The keys to access the JSON data. Keys are separated by
#                 spaces.
#
# @link https://github.com/fnichol/bashrc/blob/master/bashrc
#
json_value() {
    if [ -z $1 ]; then
        echo "Usage: json_value <key1> <key2> ... <keyN>" >&2
        return 1
    fi

    local keys=
    for key in $@; do
        keys="${keys}['${key}']"
    done
    unset key

    python -c 'import sys; import json; j = json.loads(sys.stdin.read()); print j'$keys';'
}

# Syntax-highlight JSON strings or files
function json() {
    if [ -p /dev/stdin ]; then
        # piping, e.g. `echo '{"foo":42}' | json`
        python -mjson.tool | pygmentize -l javascript
    else
        # e.g. `json '{"foo":42}'`
        python -mjson.tool <<< "$*" | pygmentize -l javascript
    fi
}

##
# Escape UTF-8 characters into their 3-byte format
#
# @link https://github.com/stevehodgkiss/dotfiles/blob/master/functions
escape() {
    printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
    echo # newline
}

##
# Decode \x{ABCD}-style Unicode escape sequences
#
# @link https://github.com/stevehodgkiss/dotfiles/blob/master/functions
#
unidecode() {
    perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
    echo # newline
}

##
# Get a character's Unicode code point
#
# @link https://github.com/stevehodgkiss/dotfiles/blob/master/functions
#
function codepoint() {
    perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
    echo # newline
}
